<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>STM32 HAL库开发学习笔记</title>
    <link href="/2024/02/29/post-8/"/>
    <url>/2024/02/29/post-8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在学习了解过 51 单片机的基本外设和其应用，对单片机作好铺垫后，肯定就到了 STM32 的学习，我选择直接学习可以快速上手的 HAL 库。本文记录基于 STM32F103C8T6 HAL 库入门开发教程的学习笔记。</p></blockquote><h2 id="0-前置知识"><a href="#0-前置知识" class="headerlink" title="0. 前置知识"></a>0. 前置知识</h2><h3 id="STM32-内部结构"><a href="#STM32-内部结构" class="headerlink" title="STM32 内部结构"></a>STM32 内部结构</h3><p>以 <strong>STM32F103xx</strong> 型号为例，该芯片由 <code>Cortex-M3 内核</code> 和 <code>片上内设</code> 组成。</p><p>ICode 总线：’I’ 代表 “Instruction”，该总线作用是 <code>取指</code>，它会一直从 <code>Flash</code> 中读取存储的数据。<br>总线矩阵：协调仲裁 DCode 总线、System 总线、DMA 总线之间的数据传输。</p><p>除了该总线，一般分为 4 个 <code>驱动单元</code> 和 4 个 <code>被动单元</code>。</p><p>驱动单元：</p><ul><li>Dcode 总线：’D’ 代表 ‘data’，该总线作用是 <code>取数</code>，它会从 Flash 中读取数据常量，从 SRAM 中读取数据变量。</li><li>System 总线：主要访问外设的寄存器。通过此总线读写寄存器。</li><li>DMA 总线 x2：DMA 总线也是用作传输数据，数据可以在某个外设的数据寄存器（Flash 或 SRAM）。</li></ul><p>被动单元：</p><ul><li>内部 Flash：存储数据和指令的地方。</li><li>内部 SRAM：程序的变量、堆栈的开销都在此区域发生。</li><li>FSMC：Flexible Static Memory Controller，通过此控制器可以扩展内存。</li><li>AHB - APB桥：AHB 分为 APB2 和 APB1 总线，这些总线上挂载在 STM32 的各种外设。<blockquote><p>英文全称：Advanced High Performance Bus &#x2F; Advanced Peripheral Bus</p></blockquote></li></ul><h3 id="存储器映射"><a href="#存储器映射" class="headerlink" title="存储器映射"></a>存储器映射</h3><p>被控单元的FLASH，RAM，FSMC 和 AHB 到 APB 的桥（即片上外设），这些功能部件共同排列在一个4GB 的地址空间内。厂商也预先为这些分配好相应的物理内存地址。</p><p>4GB 的空间被分为 8 小块 512MB，每一小块称作一个 block，对应着不同的地址区间，给已经分配好地址的有特定功能的内存单元取别名的过程就叫寄存器映射。</p><blockquote><p>此部分具体阅读野火 HAL 库实战开发指南的第 4 和第 5 章，此部分可以对整个架构和寄存器原理有一个初步理解。<br><strong>[野火] STM32 HAL 库开发实战指南——基于 F103 系列开发板</strong></p><p><strong>第 4 章：<a href="https://doc.embedfire.com/mcu/stm32/f103/hal_general/zh/latest/doc/chapter4/chapter4.html">初识 STM32</a></strong><br><strong>第 5 章：<a href="https://doc.embedfire.com/mcu/stm32/f103/hal_general/zh/latest/doc/chapter5/chapter5.html">什么是寄存器</a></strong></p></blockquote><h2 id="1-点灯大师"><a href="#1-点灯大师" class="headerlink" title="1. 点灯大师"></a>1. 点灯大师</h2><h3 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h3><p>根据原理图 <code>LED</code> 负极接 <code>GND</code> 和二极管的单向导通性（正极 -&gt; 负极），通过控制 STM32 <code>GPIO</code> 引脚使用 <code>Push-Pull Output</code>，输出 3.3V 高电平使 LED 导通。</p><ul><li>LED - Light-Emitting Diode，发光二极管。</li><li>GND - Ground 的缩写，表示接“地”，但是不是真正意义的“地”，是电路中基准电位。</li><li>GPIO：通用输入输出（General Purpose Input and Output），GPIO 引脚可以读取外部输入电压和向外输出一定电压值。</li><li>推挽输出 &amp; 开漏输出：当 GPIO 处于输出模式时，GPIO 内部的两个 MOS 管（PMOS &amp; NMOS）排列组合共有 4 个状态：<ul><li>（PMOS 高电平导通，NMOS 低电平导通）</li><li>PMOS 打开 | NMOS 关闭 - 输出高电平</li><li>PMOS 关闭 | NMOS 打开 - 输出低电平</li><li>PMOS 关闭 | NMOS 关闭 - 浮空，即高阻态</li><li>PMOS 打开 | NMOS 打开 - VCC直接连通GND短路，MOS管烧坏，不存在这种状态</li></ul></li></ul><h3 id="1-2-实验"><a href="#1-2-实验" class="headerlink" title="1.2 实验"></a>1.2 实验</h3><ul><li><p>假设使用高电平点亮绿灯，在 <code>Pinout view</code> 中选中 <code>PA7</code> 引脚，选择 <code>GPIO_Output</code>并配置 <code>GPIO output level</code> 为 <code>high</code>。</p></li><li><p>假如让 LED 灯进行闪烁，在 <code>MX_GPIO_Init()</code> 代码片段编写以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_7, GPIO_PIN_SET); <span class="hljs-comment">// 参数 GPIO_PIN_SET 设置高电平</span><br>    HAL_Delay(<span class="hljs-number">500</span>); <span class="hljs-comment">// 延时函数，参数单位为毫秒（ms）</span><br>    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_7, GPIO_PIN_RESET); <span class="hljs-comment">// 参数 GPIO_PIN_RESET 设置高电平</span><br>    HAL_Delay(<span class="hljs-number">500</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>IDE技巧和细节：</p><ul><li><code>ALT</code> + <code>/</code> - 代码提示</li><li>保留用户代码需要将编写的代码置于 <code>BEIGIN</code> 和 <code>END</code> 注释区间</li><li>引脚视图中每个引脚右键选中 <code>Enter user label</code> 可以重命名引脚名称，方便记忆与配置</li></ul></li></ul><h2 id="2-按键"><a href="#2-按键" class="headerlink" title="2. 按键"></a>2. 按键</h2><h3 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h3><p>根据原理图，KEY 未按下时，KEY 不接地处于断路状态，直接连通一个上拉电阻到 3.3V 电源。通过设定 GPIO 为 浮空输入模式，浮空输入模式的 GPIO 内部处于高阻态（相当于芯片内部有一个巨大的电阻），那么这个上拉电阻压降几乎为 0V，所以 GPIO 的电压近似可以等于接通 3.3V（高电平）。当 KEY 按下后，通路形成，KEY 处于接地状态，GPIO 即处于低电平 0V 状态。</p><ul><li>上拉：使用电源将 GPIO 的电平拉高的操作称作上拉，通常需要一个上拉电阻配合。</li><li>下拉：类似上拉，接通的不是电源而是接地的话，那么该操作称为下拉。</li><li>电压降：电流流过负载以后相对于同一参考点的电势（电位）变化称为电压降，简称压降。</li><li>浮空输入模式：输入信号经过施密特触发器接入输入数据存储器。当无信号输入时，电压不确定。</li><li>消抖：硬件消抖可以采用电容，但传统软件消抖方法是使用延时函数。</li></ul><h3 id="2-2-实验"><a href="#2-2-实验" class="headerlink" title="2.2 实验"></a>2.2 实验</h3><ul><li><p>假设使用 KEY1 点亮蓝灯，在 <code>Pinout view</code> 中选中 KEY1 的 <code>GPIO_Input</code> 后，编写以下自定义代码片段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br> HAL_GPIO_ReadPin(KEY1_GPIO_Port, KEY1_Pin); <span class="hljs-comment">// 使用 ReadPin 函数读取是否为低电平</span><br> <span class="hljs-keyword">if</span> (HAL_GPIO_ReadPin(KEY1_GPIO_Port, KEY1_Pin) == GPIO_PIN_RESET)<br> &#123;<br>  HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, GPIO_PIN_SET);<br> &#125;<span class="hljs-keyword">else</span><br>    &#123;<br>  HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, GPIO_PIN_RESET);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>STM32 内部有内置的上拉或下拉电阻，即原理图上的 KEY2 没有连接任何电阻。在引脚设置中同样选中 KEY2 的 <code>GPIO_Input</code>，打开详细配置可以发现上拉下拉中默认为<code>no pull-up and on pull-down</code>，即默认为浮空输入模式，然后需要选择使用内部的 <code>pull-up</code> 上拉电阻后编写以下自定义代码片段使用 KEY2 控制红灯亮灭切换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (HAL_GPIO_ReadPin(KEY2_GPIO_Port, KEY2_Pin) == GPIO_PIN_RESET)<br>&#123;<br>  HAL_GPIO_TogglePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin); <span class="hljs-comment">// 使用 TogglePin 函数切换高低电平</span><br>  <span class="hljs-keyword">while</span>(HAL_GPIO_ReadPin(KEY2_GPIO_Port, KEY2_Pin) == GPIO_PIN_RESET)&#123;&#125; <span class="hljs-comment">// 使用 while 检测按键是否被松开，再继续执行逻辑</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>软件消抖方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (HAL_GPIO_ReadPin(KEY2_GPIO_Port, KEY2_Pin) == GPIO_PIN_RESET)<br>&#123;<br>HAL_Delay(<span class="hljs-number">10</span>); <span class="hljs-comment">// 按键按下后，初次读取电平后延时 10ms</span><br><span class="hljs-keyword">if</span> (HAL_GPIO_ReadPin(KEY2_GPIO_Port, KEY2_Pin) == GPIO_PIN_RESET) <span class="hljs-comment">// 待稳定后再次读取电平</span><br>&#123;<br>HAL_GPIO_TogglePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin); <span class="hljs-comment">// 使用 TogglePin 函数切换高低电平</span><br>  <span class="hljs-keyword">while</span>(HAL_GPIO_ReadPin(KEY2_GPIO_Port, KEY2_Pin) == GPIO_PIN_RESET)&#123;&#125; <span class="hljs-comment">// 使用 while 检测按键是否被松开，再继续执行逻辑</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-GPIO-深入理解"><a href="#3-GPIO-深入理解" class="headerlink" title="3. GPIO 深入理解"></a>3. GPIO 深入理解</h2><p>在 STM32 参考手册内可以找到 GPIO 引脚内部结构如下图所示，GPIO 有八大功能模式，其主要分为<strong>输出</strong>和<strong>输入</strong>两部分。</p><h3 id="3-1-引脚部分"><a href="#3-1-引脚部分" class="headerlink" title="3.1 引脚部分"></a>3.1 引脚部分</h3><p>因为引脚能承受的电压有限，引脚部分两侧是两个保护二极管，类似静电等瞬间电压进入引脚时，如果电压大于 VDD 3.3V，上方二极管导通；若电压小于VSS 0V时，下方二极管导通。尽管有保护二极管，长时间接入高负载电压也是会损坏芯片。（部分 IO 口可以承受 5V 电压）</p><img src="/2024/02/29/post-8/post-8-1.png" class=""><h3 id="3-2-输出部分"><a href="#3-2-输出部分" class="headerlink" title="3.2 输出部分"></a>3.2 输出部分</h3><ul><li><p>推挽输出：因为 PMOS 管高电平导通，VDD 输出 3.3V 高电平，这一动作称为“推”。反之，低电平 NMOS 导通，GND 输出 0V 低电平，电流往 GND 流动，这一动作称作“挽”。推挽输出具有一定的电压和电流驱动能力，但能力不高，比如 5V 的器件无法驱动。</p></li><li><p>开漏输出：在此模式下，PMOS 管不工作，只会使用到 NMOS。GPIO 输出高电平 NMOS 不导通，即处于高阻态模式。假设我们想驱动一个连接外部 5V VDD 的工作电压为 5V 器件，那么输出高低电平就可以控制这个器件工作。开漏输出没有驱动能力，但其更加灵活，可以依靠外部电压源。</p></li><li><p>复用推挽输出：区别于普通推挽输出的复用模式，其输出源来自片上外设。</p></li><li><p>复用开漏输出：区别于普通开漏输出的复用模式，其输出源来自片上外设。</p></li></ul><h3 id="3-3-输入部分"><a href="#3-3-输入部分" class="headerlink" title="3.3 输入部分"></a>3.3 输入部分</h3><p>由于电压并不总是稳定的，电流在输入部分会流经一个施密特触发器，其带有两个参考电压值，判断和输出处理的电平信号，即 1 和 0。后面的输入数据寄存器就可以读取输入的电平。</p><ul><li><p>上拉输入：设置上拉输入，上拉电阻启用。</p></li><li><p>下拉输入：设置下拉输入，下拉电阻启用。</p></li><li><p>浮空输入：两个上下拉电阻均不启用，可以依赖外部电路实现更丰富的功能。</p></li><li><p>模拟输入：读取具体的电压数值，它在施密特触发器之前，将电压引入至与模拟输入相关的片上外设。</p></li></ul><h2 id="4-中断"><a href="#4-中断" class="headerlink" title="4. 中断"></a>4. 中断</h2><p>中断是 CPU 在接收到中断源信号后转而优先处理中断源任务的一个过程。 举例一个简单的中断输入结构和流程，当按键按下后，外部电平信号经过上下拉电阻、施密特触发器转换、最后抵达输入数据寄存器或者片上外设。再进一步，电平信号会抵达以下结构，即外部<strong>中断&#x2F;事件控制器</strong>。</p><h3 id="4-1-中断-事件控制器结构"><a href="#4-1-中断-事件控制器结构" class="headerlink" title="4.1 中断&#x2F;事件控制器结构"></a>4.1 中断&#x2F;事件控制器结构</h3><ul><li>STM32 一共有 19 组这样的线路结构，每一个外部中断都应着其中的一组线路，也称作<strong>外部中断线</strong>，前 16 组 <code>EXIT0</code> ~ <code>EXIT15</code> 分别对应相应的 GPIO。</li></ul><table><thead><tr><th>中断号</th><th>GPIO引脚</th><th>GPIO引脚</th><th>GPIO引脚</th><th>GPIO引脚</th></tr></thead><tbody><tr><td>EXIT0</td><td>PA0</td><td>PB0</td><td>PC0</td><td>PD0</td></tr><tr><td>EXIT1</td><td>PA1</td><td>PB1</td><td>PC1</td><td>PD1</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td><td>……</td></tr><tr><td>EXITX</td><td>PAX</td><td>PBX</td><td>PCX</td><td>PDX</td></tr></tbody></table><ul><li><code>脉冲发生器</code> 和 <code>事件屏蔽器</code> 可以先暂时忽略，是与 <code>事件</code> 相关的。中断信号是会抵达处理器调用代码进行处理。而事件信号是送达相应的外设，由外设自行处理。</li></ul><img src="/2024/02/29/post-8/post-8-2.png" class=""><br/><br/><h3 id="4-2-原理"><a href="#4-2-原理" class="headerlink" title="4.2 原理"></a>4.2 原理</h3><p>电信号进入 <code>边沿检测电路</code> ，由 <code>上升沿</code> 和 <code>上升沿</code> 两个触发选择寄存器（CubeMX 选择）检测后输出高电平，请求挂起寄存器接收到电信号后，将其第 12 位置 1，再次将电信号传到一个与门，当 <code>中断屏蔽寄存器</code> 中的第 12 位 同样置 1 时，那么电信号才能再次输送到 <code>NVIC（中断控制器）</code>。</p><ul><li>到达 NVIC 后，控制器会根据几号的外部中断线，选择对应的中断向量，随后执行相应的处理函数。</li></ul><table><thead><tr><th>名称（中断向量）</th><th>处理函数</th></tr></thead><tbody><tr><td>EXIT0</td><td>EXIT0_IRQHandler</td></tr><tr><td>EXIT1</td><td>EXIT1_IRQHandler</td></tr><tr><td>EXIT2</td><td>EXIT2_IRQHandler</td></tr><tr><td>EXIT3</td><td>EXIT3_IRQHandler</td></tr><tr><td>EXIT4</td><td>EXIT4_IRQHandler</td></tr><tr><td>……</td><td>……</td></tr><tr><td>EXIT9_5</td><td>EXIT9_5_IRQHandler</td></tr><tr><td>EXIT15_10</td><td>EXIT15_10_IRQHandler</td></tr></tbody></table><ul><li><p>由于 NVIC 会一直检测中断线是否处于激活状态，所以在执行一次处理函数后便需要重置 <code>请求挂起寄存器</code>，CubeMX 会自动生成函数代码执行这个操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_GPIO_EXIT_IRQHandler();<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-3-中断优先级"><a href="#4-3-中断优先级" class="headerlink" title="4.3 中断优先级"></a>4.3 中断优先级</h3><p>倘若多个中断同时发生，单片机如何安排这些执行顺序？STM32 中断优先级分为两种（数字越小越优先）：</p><ul><li>抢占优先级</li><li>响应优先级</li></ul><p>NVIC 会有以下的判断规则：</p><table><thead><tr><th>情况</th><th>比较顺序</th></tr></thead><tbody><tr><td>1 - 两个中断同时发生</td><td>1 - 抢占优先级</td></tr><tr><td></td><td>2 - 响应优先级</td></tr><tr><td></td><td>3 - 向量表数字</td></tr><tr><td>2- A执行中，B发生</td><td>1 - 抢占优先级</td></tr></tbody></table><p>STM32 每个中断向量准备 4 个二进制位来储存中断优先级信息，CubeMX 默认是 4 位都设置抢占优先级（0 ~ 15）</p><h3 id="4-3-实验"><a href="#4-3-实验" class="headerlink" title="4.3 实验"></a>4.3 实验</h3><p><code>main.c</code> 编写 LED 亮灭代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br> HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, GPIO_PIN_SET);<br> HAL_Delay(<span class="hljs-number">2000</span>);<br> HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, GPIO_PIN_RESET);<br> HAL_Delay(<span class="hljs-number">2000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>将 <code>PB12</code> 引脚设置为 <code>GPIO_EXIT2</code>，并选择<code>下沿触发模式</code>；设置 NVIC 模块中 <code>System Tick</code> 抢占优先级（14） &gt;<code> EXIT line</code> 抢占优先级（15）</p><p><code>stm32f1xx_it.c</code> 编写中断函数 - 检测到下沿触发后执行此函数：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">void EXTI15_10_IRQHandler(void)<br>&#123;<br>  /* <span class="hljs-keyword">USER</span> <span class="hljs-title">CODE</span> BEGIN EXTI15_10_IRQn <span class="hljs-number">0</span> */<br>HAL_Delay(<span class="hljs-number">10</span>);<br>if(HAL_GPIO_ReadPin(KEY1_GPIO_Port, KEY1_Pin) == GPIO_PIN_RESET)<br>&#123;<br>HAL_GPIO_TogglePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin);<br>&#125;<br>  /* <span class="hljs-keyword">USER</span> <span class="hljs-title">CODE</span> END EXTI15_10_IRQn <span class="hljs-number">0</span> */<br>  HAL_GPIO_EXTI_IRQHandler(KEY1_Pin);<br>  /* <span class="hljs-keyword">USER</span> <span class="hljs-title">CODE</span> BEGIN EXTI15_10_IRQn <span class="hljs-number">1</span> */<br><br>  /* <span class="hljs-keyword">USER</span> <span class="hljs-title">CODE</span> END EXTI15_10_IRQn <span class="hljs-number">1</span> */<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-串口通信"><a href="#5-串口通信" class="headerlink" title="5. 串口通信"></a>5. 串口通信</h2><h3 id="5-1-原理"><a href="#5-1-原理" class="headerlink" title="5.1 原理"></a>5.1 原理</h3><p>普通 TTL 串口的收发结构如下图所示，TX 是发送端，RX 是接收端，GND 是共地（设备正常通讯的前提，保证同一电平）</p><img src="/2024/02/29/post-8/post-8-3.png" class=""><br/><br/><h3 id="5-2-USART-实验"><a href="#5-2-USART-实验" class="headerlink" title="5.2 USART 实验"></a>5.2 USART 实验</h3><p><strong>USART 全称：Universal Synchronous &#x2F; Asynchronous Receiver &amp; Transmitter（通用同步&#x2F;异步接收发送器）</strong>。</p><p>TTL 串口使用的是异步通信方式。打开 CubeMX，在 <code>Connectivity</code> 下可以见到有 3 个 USART 外设资源。 根据原理图，这里调试串口使用的 IO 口是 <code>PA2</code>、<code>PA3</code>。</p><img src="/2024/02/29/post-8/post-8-4.png" class=""><p>将 PA2 引脚设置为 USART2_TX，同时设置 Mode 为 Asynchronous，随后 PA2 和 PA3 自动分别设置为 TX 和 RX。还需要特别注意一些参数：</p><ul><li>波特率：Baud Rate - 每秒多少次高低电平信号。TTL 串口默认每次传输一个字节（Byte）数据，同时还要添加前后的起始位和停止位，即总共 10bit。通信设备两端都要使用一样的波特率才可以正常通信。</li></ul><img src="/2024/02/29/post-8/post-8-5.png" class=""><p>发送数据到 PC - 编写代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">  MX_USART2_UART_Init();<br>  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span><br>  <span class="hljs-type">char</span> message[] = <span class="hljs-string">&quot;Hello!&quot;</span>;<br>  <span class="hljs-comment">/* USER CODE END 2 */</span><br><br>  <span class="hljs-comment">/* Infinite loop */</span><br>  <span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>  &#123;<br>    <span class="hljs-comment">/* USER CODE END WHILE */</span><br>    HAL_UART_Transmit(&amp;huart2, (<span class="hljs-type">uint8_t</span>*)message, <span class="hljs-built_in">strlen</span>(message), <span class="hljs-number">100</span>);<br>    HAL_Delay(<span class="hljs-number">1000</span>);<br>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span><br>  &#125;<br>  <span class="hljs-comment">/* USER CODE END 3 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接受来自 PC 数据 - 编写代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">/* Initialize all configured peripherals */</span><br> MX_GPIO_Init();<br> MX_USART2_UART_Init();<br> <span class="hljs-comment">/* USER CODE BEGIN 2 */</span><br><br> <span class="hljs-type">uint8_t</span> dataReceived[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 声明接受数据数组</span><br><br> <span class="hljs-comment">/* USER CODE END 2 */</span><br><br> <span class="hljs-comment">/* Infinite loop */</span><br> <span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><br> <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br> &#123;<br>   HAL_UART_Receive(&amp;huart2, dataReceived, <span class="hljs-number">2</span>, HAL_MAX_DELAY); <span class="hljs-comment">// 调用接收函数</span><br>   HAL_UART_Transmit(&amp;huart2, dataReceived, <span class="hljs-number">2</span>, <span class="hljs-number">100</span>); <span class="hljs-comment">// 调用发送函数</span><br>   <br>   GPIO_PinState state = GPIO_PIN_RESET;<br><br><span class="hljs-comment">// 根据接收的数据判断逻辑控制小灯亮灭</span><br>   <span class="hljs-keyword">if</span> (dataReceived[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>   &#123;<br>     state = GPIO_PIN_SET;<br>   &#125;<br>   <br>   <span class="hljs-keyword">if</span> (dataReceived[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;R&#x27;</span>)<br>   &#123;<br>     HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, state);<br>   &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dataReceived[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;G&#x27;</span>)<br>   &#123;<br>     HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, state);<br>   &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dataReceived[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;B&#x27;</span>)<br>   &#123;<br>     HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, state);<br>   &#125;<br><br>   <span class="hljs-comment">/* USER CODE END WHILE */</span><br><br>   <span class="hljs-comment">/* USER CODE BEGIN 3 */</span><br> &#125;<br> <span class="hljs-comment">/* USER CODE END 3 */</span><br></code></pre></td></tr></table></figure><h3 id="5-3-轮询模式"><a href="#5-3-轮询模式" class="headerlink" title="5.3 轮询模式"></a>5.3 轮询模式</h3><p><strong>以上实验的收发方式称为轮询模式，这种模式效果不佳，会阻塞程序执行，因为 CPU 在一直查询数据并传入移位寄存器，直到完成发送或接收或者等待超时</strong>。</p><p>该模式会使用到两对寄存器：</p><ul><li>发送数据寄存器（TDR）&amp; 发送移位寄存器（TX）</li><li>接收数据寄存器（RDR） &amp; 接收移位寄存器（RD）</li></ul><h3 id="5-4-中断模式"><a href="#5-4-中断模式" class="headerlink" title="5.4 中断模式"></a>5.4 中断模式</h3><p>因为我们引入了中断串口模式，打开 USART2 的中断功能，随后使用中断串口函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_UART_Transmit_IT(&amp;huart2, [pData], [size]);<br>HAL_UART_Receive_IT(&amp;huart2, [pData], [size]);<br></code></pre></td></tr></table></figure><img src="/2024/02/29/post-8/post-8-6.png" class=""><p>在此模式中，不能把中断逻辑写在 <code>void USART2_IRQHandler(void)</code> 里，因为 所有USART 只有一个中断向量，需要重新定义以下回调函数（接收完成时才调用此函数）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_UART_RxCpltCallback</span><span class="hljs-params">(UART_HandleTypeDef *huart)</span><br>&#123;<br>    HAL_UART_Transmit_IT(&amp;huart2, dataReceived, <span class="hljs-number">2</span>);<br><br>    GPIO_PinState state = GPIO_PIN_SET;<br><br>    <span class="hljs-keyword">if</span> (dataReceived[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>    &#123;<br>      state = GPIO_PIN_RESET;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (dataReceived[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;R&#x27;</span>)<br>    &#123;<br>      HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, state);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dataReceived[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;G&#x27;</span>)<br>    &#123;<br>      HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, state);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dataReceived[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;B&#x27;</span>)<br>    &#123;<br>      HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, state);<br>    &#125;<br><br>    HAL_UART_Receive_IT(&amp;huart2, dataReceived, <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>另外接收不要放在 while 循环中执行，否则上一次没有接收完，又重复执行此函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_UART_Receive_IT(&amp;huart2, dataReceived, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h3 id="5-5-DMA-模式"><a href="#5-5-DMA-模式" class="headerlink" title="5.5  DMA 模式"></a>5.5  DMA 模式</h3><p>对于中断模式，CPU 会被频繁打断去处理中断搬运数据（TDR -&gt; 发送移位寄存器）（ODR -&gt; 接受移位寄存器）。此时我们可以使用 DMA 来代替 CPU “搬运”数据，HAL 函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_UART_Receive_DMA();<br>HAL_UART_Transimit_DMA();<br></code></pre></td></tr></table></figure><p>如何接收不定长数据？利用串口空闲中断状态（IDLE），即串口完成一帧的数据包输入输出。HAL 函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_UARTEx_ReceiveToIdle_DMA(); <br></code></pre></td></tr></table></figure><h2 id="6-蓝牙"><a href="#6-蓝牙" class="headerlink" title="6. 蓝牙"></a>6. 蓝牙</h2><h3 id="6-1-原理"><a href="#6-1-原理" class="headerlink" title="6.1 原理"></a>6.1 原理</h3><p>蓝牙分为经典蓝牙和低功耗蓝牙（BLE）。蓝牙通讯分为 <code>主机</code> 和 <code>从机</code>。</p><p>BT24 蓝牙串口透传模块：转化复杂的蓝牙协议为串口透传</p><h3 id="6-2-实验"><a href="#6-2-实验" class="headerlink" title="6.2 实验"></a>6.2 实验</h3><p><strong>普通蓝牙通讯</strong></p><ol><li><p>使用杜邦线连接蓝牙模块到开发板</p></li><li><p>开启 <code>USART3</code> 并设置异步通信方式</p></li><li><p>更改波特率到 <code>9600</code>（蓝牙模块默认）</p></li><li><p>开启 接收与发送 <code>DMA</code> 通道</p></li><li><p>编写回调函数代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint8_t</span> data[<span class="hljs-number">50</span>]; <span class="hljs-comment">// 声明数据数组</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_UARTEx_RxEventCallback</span><span class="hljs-params">(UART_HandleTypeDef *huart, <span class="hljs-type">uint16_t</span> Size)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (huart == &amp;huart3)<br>  &#123;<br>    HAL_UART_Transmit_DMA(&amp;huart3, data, Size); <span class="hljs-comment">// size 参数代表发送与接收相同的字节数</span><br>  &#125;<br>  <br>  HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart3, data, <span class="hljs-keyword">sizeof</span>(data));<br>  __HAL_DMA_DISABLE_IT(&amp;hdma_usart3_rx, DMA_IT_HT);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编写第一次接收数据函数（接收不定长数据）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart3, data, <span class="hljs-keyword">sizeof</span>(data));<br>__HAL_DMA_DISABLE_IT(&amp;hdma_usart3_rx, DMA_IT_HT);<br></code></pre></td></tr></table></figure></li><li><p>编译烧录后，使用串口助手验证</p></li></ol><p><strong>蓝牙通讯控制LED灯</strong></p><ol><li><p>定义 <code>0xFF</code> 亮灯 <code>0x00</code> 灭灯</p></li><li><p><code>0x01</code> <code>0x02</code> <code>0x03</code> 分别代表红绿蓝灯</p></li><li><p>定义一帧数据数据包：<code>包头</code> <code>数据长度</code> <code>LED</code> <code>亮灭状态</code> <code>检验和</code></p><blockquote><p>校验位用于检验输出数据的正确与否，计算方式是将前面的数据依次相加，取最后一字节数据，接收后会进行对比，如果相同证明大概率没有出错。</p></blockquote></li><li><p>开启三个 <code>LED</code> 灯的 <code>GPIO</code></p></li><li><p>编写回调函数代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_UARTEx_RxEventCallback</span><span class="hljs-params">(UART_HandleTypeDef *huart, <span class="hljs-type">uint16_t</span> Size)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(huart == &amp;huart3)<br>  &#123;<br>    HAL_UART_Transmit_DMA(&amp;huart3, data, Size);<br><br>    <span class="hljs-keyword">if</span> (data[<span class="hljs-number">0</span>] == <span class="hljs-number">0xAA</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (data[<span class="hljs-number">1</span>] == Size)<br>      &#123;<br>        <span class="hljs-type">uint8_t</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; Size - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>          sum += data[i];<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (sum == data[Size - <span class="hljs-number">1</span>])<br>        &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; Size - <span class="hljs-number">1</span>; i+=<span class="hljs-number">2</span>)<br>          &#123;<br>            GPIO_PinState state = GPIO_PIN_SET;<br>            <span class="hljs-keyword">if</span> (data[i+<span class="hljs-number">1</span>] == <span class="hljs-number">0x00</span>)<br>            &#123;<br>              state = GPIO_PIN_RESET;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (data[i] == <span class="hljs-number">0x01</span>)<br>            &#123;<br>              HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, state);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data[i] == <span class="hljs-number">0x02</span>)<br>            &#123;<br>              HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, state);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data[i] == <span class="hljs-number">0x03</span>)<br>            &#123;<br>              HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, state);<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart3, data, <span class="hljs-keyword">sizeof</span>(data));<br>    __HAL_DMA_DISABLE_IT(&amp;hdma_usart3_rx, DMA_IT_HT);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编写第一次接收数据函数（接收不定长数据）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart3, data, <span class="hljs-keyword">sizeof</span>(data));<br>__HAL_DMA_DISABLE_IT(&amp;hdma_usart3_rx, DMA_IT_HT);<br></code></pre></td></tr></table></figure></li></ol><h2 id="7-IIC"><a href="#7-IIC" class="headerlink" title="7. IIC"></a>7. IIC</h2><h3 id="7-1-原理"><a href="#7-1-原理" class="headerlink" title="7.1 原理"></a>7.1 原理</h3><p>SDA：Serial Data<br>SCL：Serial Clock</p><p>SDA 线允许双向通信，但同一时刻只能有一个方向，是半双工模式。为了避免冲突，IIC 采用主从模式。这一特性可以与多设备进行通信。</p><p>IIC 采用同步通信，主机通过时钟信号线发送固定频率的脉冲信号作为所有设备的统一时间源。</p><h3 id="7-2-实验-AHT20-温湿度计（普通轮询模式）"><a href="#7-2-实验-AHT20-温湿度计（普通轮询模式）" class="headerlink" title="7.2 实验 - AHT20 温湿度计（普通轮询模式）"></a>7.2 实验 - AHT20 温湿度计（普通轮询模式）</h3><ol><li><p>新建工程 CubeMX 开启 UART 串口 -用于读取返回数据</p></li><li><p>CubeMX 开启 I2C1</p></li><li><p>CubeMX 工程开启分别为外设添加头文件和源文件，然后单独新建 aht20.h 和 aht20.c</p></li><li><p>编写驱动头文件 aht20.h：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">/*</span><br><span class="hljs-comment"> * aht20.h</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  Created on: Mar 23, 2024</span><br><span class="hljs-comment"> *      Author: iamcc</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> INC_AHT20_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INC_AHT20_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;i2c.h&quot;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">AHT20_Init</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">AHT20_Read</span><span class="hljs-params">(<span class="hljs-type">float</span> *Temperature, <span class="hljs-type">float</span> *Humidity)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* INC_AHT20_H_ */</span></span><br></code></pre></td></tr></table></figure></li><li><p>编写驱动源文件 aht20.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * aht20.c</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  Created on: Mar 23, 2024</span><br><span class="hljs-comment"> *      Author: iamcc</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;aht20.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AHT_20_ADDRESS 0x70</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">AHT20_Init</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> readBuffer;<br>    HAL_Delay(<span class="hljs-number">40</span>);<br>    HAL_I2C_Master_Receive(&amp;hi2c1, AHT_20_ADDRESS, &amp;readBuffer, <span class="hljs-number">1</span>, HAL_MAX_DELAY);<br><br>    <span class="hljs-keyword">if</span> ((readBuffer &amp; <span class="hljs-number">0x80</span>) == <span class="hljs-number">0x00</span>)<br>    &#123;<br>        <span class="hljs-type">uint8_t</span> sendBuffer[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0xBE</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x00</span>&#125;;<br>        HAL_I2C_Master_Transmit(&amp;hi2c1, AHT_20_ADDRESS, sendBuffer, <span class="hljs-number">3</span>, HAL_MAX_DELAY);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">AHT20_Read</span><span class="hljs-params">(<span class="hljs-type">float</span> *Temperature, <span class="hljs-type">float</span> *Humidity)</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> sendBuffer[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0xAC</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x00</span>&#125;;<br>    <span class="hljs-type">uint8_t</span> readBuffer[<span class="hljs-number">6</span>];<br><br>    HAL_I2C_Master_Transmit(&amp;hi2c1, AHT_20_ADDRESS, sendBuffer, <span class="hljs-number">3</span>, HAL_MAX_DELAY);<br>    HAL_Delay(<span class="hljs-number">75</span>);<br>    HAL_I2C_Master_Receive(&amp;hi2c1, AHT_20_ADDRESS, readBuffer, <span class="hljs-number">6</span>, HAL_MAX_DELAY);<br><br>    <span class="hljs-keyword">if</span> ((readBuffer[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x80</span>) == <span class="hljs-number">0x00</span>)<br>    &#123;<br>        <span class="hljs-type">uint32_t</span> data = <span class="hljs-number">0</span>;<br>        data = ((<span class="hljs-type">uint32_t</span>)readBuffer[<span class="hljs-number">3</span>] &gt;&gt; <span class="hljs-number">4</span>) + ((<span class="hljs-type">uint32_t</span>)readBuffer[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">4</span>) + ((<span class="hljs-type">uint32_t</span>)readBuffer[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">12</span>);<br>        *Humidity = data * <span class="hljs-number">100.0f</span> / (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>);<br><br>        data = ((<span class="hljs-type">uint32_t</span>)readBuffer[<span class="hljs-number">3</span>] &amp; <span class="hljs-number">0x0F</span> &lt;&lt; <span class="hljs-number">16</span>) + ((<span class="hljs-type">uint32_t</span>)readBuffer[<span class="hljs-number">4</span>] &lt;&lt; <span class="hljs-number">8</span>) + ((<span class="hljs-type">uint32_t</span>)readBuffer[<span class="hljs-number">5</span>]);<br>        *Temperature = data * <span class="hljs-number">200.0f</span> / (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>) - <span class="hljs-number">50</span>;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编写 main.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Private includes ----------------------------------------------------------*/</span><br><span class="hljs-comment">/* USER CODE BEGIN Includes */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;aht20.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-comment">/* USER CODE END Includes */</span><br><br>  <span class="hljs-comment">/* Initialize all configured peripherals */</span><br>  MX_GPIO_Init();<br>  MX_I2C1_Init();<br>  MX_USART2_UART_Init();<br>  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span><br>  AHT20_Init();<br>  <span class="hljs-type">float</span> temperature, humidity;<br>  <span class="hljs-type">char</span> message[<span class="hljs-number">50</span>];<br>  <span class="hljs-comment">/* USER CODE END 2 */</span><br><br>  <span class="hljs-comment">/* Infinite loop */</span><br>  <span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>  &#123;<br>    AHT20_Read(&amp;temperature, &amp;humidity);<br>    <span class="hljs-built_in">sprintf</span>(message, <span class="hljs-string">&quot;Temp: %.1f °C\nHumi: %.1f %%\r\n&quot;</span>, temperature, humidity);<br>    HAL_UART_Transmit(&amp;huart2, (<span class="hljs-type">uint8_t</span>*)message, <span class="hljs-built_in">strlen</span>(message), HAL_MAX_DELAY); <br>    HAL_Delay(<span class="hljs-number">5000</span>);<br>    <span class="hljs-comment">/* USER CODE END WHILE */</span><br><br>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span><br>  &#125;<br>  <span class="hljs-comment">/* USER CODE END 3 */</span><br></code></pre></td></tr></table></figure></li><li><p>连接串口后在串口助手观察读取的温湿度</p></li></ol><h3 id="7-3-实验-AHT20-温湿度计（中断模式）"><a href="#7-3-实验-AHT20-温湿度计（中断模式）" class="headerlink" title="7.3 实验 - AHT20 温湿度计（中断模式）"></a>7.3 实验 - AHT20 温湿度计（中断模式）</h3><p>区别于普通轮询模式，中断模式要再开启 I2C 的中断向量 - <code>I2C event interrupt</code>，对应 I2C HAL 函数最后加上 IT 或者 DMA，与 UART 类似。</p><h2 id="8-OLED"><a href="#8-OLED" class="headerlink" title="8. OLED"></a>8. OLED</h2><h3 id="8-1-原理"><a href="#8-1-原理" class="headerlink" title="8.1 原理"></a>8.1 原理</h3>]]></content>
    
    
    
    <tags>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式硬件基础与常用电子元器件原理</title>
    <link href="/2024/02/15/post-7/"/>
    <url>/2024/02/15/post-7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>模拟电子和数字电路是作为硬件知识的根基，本文将整理嵌入式开发需要了解的硬件基础知识和常用电子元器件的学习笔记，本篇笔记肯定不能完全涵盖模电与数电的全部内容，目标是对嵌入式开发有入门的硬件认知，有时间会计划深入完整学习更多，满足嵌入式软件开发所需要掌握硬件知识的要求即可。</p></blockquote><h2 id="1-电路基础"><a href="#1-电路基础" class="headerlink" title="1. 电路基础"></a>1. 电路基础</h2><h3 id="1-1-欧姆定律"><a href="#1-1-欧姆定律" class="headerlink" title="1.1 欧姆定律"></a>1.1 欧姆定律</h3><p>从最基础开始，欧姆定律揭示了电路中电压、电流和电阻三者之间的关系，即电压等于电流和电阻的乘积。当电阻恒定时，电压和电流成正比关系；当电压恒定时，电流和电阻成反比关系。</p><ul><li><strong>欧姆定律公式：U &#x3D; I × R</strong></li></ul><h4 id="1-1-1-串联分压"><a href="#1-1-1-串联分压" class="headerlink" title="1.1.1 串联分压"></a>1.1.1 串联分压</h4><p>假设电路有 R1 和 R2 两个电阻串联，根据欧姆定律，可以得出两个串联电阻的分压公式，如下图所示。这说明，各串联电阻的电压与其阻值成正比，阻值越大的电阻，分得的电压就越大。</p><img src="/2024/02/15/post-7/post-7-1.png" class="" width="300" height="80"><h4 id="1-1-2-并联分流"><a href="#1-1-2-并联分流" class="headerlink" title="1.1.2 并联分流"></a>1.1.2 并联分流</h4><p>类似两个电阻串联的分压公式，两个电阻并联分流公式如下图所示。从公式可以看出，各并联电阻的电流与其阻值成反相关，即该电阻越大，其电流就越小。另外可以发现，分流公式中，各支路电流公式的分子为另一支路电阻。</p><img src="/2024/02/15/post-7/post-7-2.png" class="" width="350" height="80"><h3 id="1-2-基尔霍夫定律"><a href="#1-2-基尔霍夫定律" class="headerlink" title="1.2 基尔霍夫定律"></a>1.2 基尔霍夫定律</h3><p>基尔霍夫定律是用来求解复杂电路的电学分析基本定律。从19世纪40年代，由于电气技术发展的十分迅速，电路变得愈来愈复杂。某些电路呈现出网络形状，并且网络中还存在一些由3条或3条以上支路形成的交点(节点)。这种复杂电路不是串、并联电路的公式所能解决的。</p><ul><li>基尔霍夫第一定律（KCL）：基尔霍夫第一定律又称基尔霍夫电流定律，简记为KCL，是电流的连续性在集总参数电路上的体现，其物理背景是电荷守恒公理。基尔霍夫电流定律是确定电路中任意节点处各支路电流之间关系的定律，因此又称为节点电流定律。<strong>基尔霍夫电流定律表明：所有进入某节点的电流的总和等于所有离开这节点的电流的总和。</strong></li><li>基尔霍夫第二定律（KVL）：基尔霍夫第二定律又称基尔霍夫电压定律，简记为KVL，是电场为位场时电位的单值性在集总参数电路上的体现，其物理背景是能量守恒。基尔霍夫电压定律是确定电路中任意回路内各电压之间关系的定律，因此又称为回路电压定律。<strong>基尔霍夫电压定律表明：沿着闭合回路所有元件两端的电势差（电压）的代数和等于零。</strong></li></ul><h2 id="2-半导体"><a href="#2-半导体" class="headerlink" title="2. 半导体"></a>2. 半导体</h2><p>在深入了解模电数电和电子元器件之前，我们首先需要了解的是现代电路世界的基础 - 半导体， 半导体是一种介于导体（如金属）和绝缘体（如塑料）之间的电子材料。半导体的电导率介于导体和绝缘体之间，这使得它们在电子器件和集成电路中起到关键作用。半导体材料通常是硅（Si）和锗（Ge），利用半导体能制造出功能复杂的元器件和集成电路。现在公认的半导体理论基础也是 1949 年的 PN 结理论。</p><h3 id="2-1-PN-结"><a href="#2-1-PN-结" class="headerlink" title="2.1 PN 结"></a>2.1 PN 结</h3><ul><li><p>PN结形成： 通过将 N 型半导体和 P 型半导体直接结合，形成了 PN 结。在 PN 结的交界处，由于 P 型和 N 型半导体的电子互相扩散，形成了一个被称为空间电荷区或电势垒的区域。</p></li><li><p>电势垒： 在 PN 结的空间电荷区，电子从 N 型区向 P 型区移动，同时空穴从 P 型区向 N 型区移动。这造成了在空间电荷区中的电荷分离，形成电势垒。电势垒的形成导致了两侧的电荷分布不均，形成了一个电场。</p></li><li><p>禁带： 在 PN 结的空间电荷区，形成了一个禁带，阻止电子和空穴继续移动。为了使电子和空穴通过，它们必须克服这个禁带。</p></li><li><p>正向偏置： 当在P型半导体端连接正电压，而 N 型半导体端连接负电压时，这称为正向偏置。正向偏置会缩小电势垒，使电子和空穴能够克服禁带并流过 PN 结。在正向偏置下，呈导通状态。</p></li><li><p>反向偏置： 当在P型半导体端连接负电压，而N型半导体端连接正电压时，这称为反向偏置。反向偏置会增加电势垒，阻止电子和空穴通过PN结。在反向偏置下，呈截止状态。</p></li></ul><blockquote><p>✅ 推荐科普视频 - <a href="https://www.bilibili.com/video/BV1774114798/">编程前你最好了解的基本硬件和计算机基础知识（模拟电路）by @Ele实验室</a></p></blockquote><h3 id="2-2-二极管"><a href="#2-2-二极管" class="headerlink" title="2.2 二极管"></a>2.2 二极管</h3><p>二极管是半导体器件家族里的“元老”，二极管就是是由一块 P 型半导体和一块 N 型半导体紧密地结合在一起而构成，在P型半导体和N型半导体的交界面上形成一个特殊的分界面，即上述提到的 PN 结。因为 PN 结具有单向导电性，电流只能从 P 型半导体一端流向 N 型半导体一端，PN 结的结构如图所示：</p><img src="/2024/02/15/post-7/post-7-3.png" class="" width="300" height="100"><br/><br/><p>将 P 型和 N 型半导体上各加上一根引线引出并封装起来，就构成一个二极管。与P型半导体连接的引线为正极，与N型半导体连接的引线为负极。</p><p>二极管的特点是单向导通性，在正向偏置下导通，而在反向偏置下截止。这使得二极管成为许多电子电路中的基本构建模块，例如整流器、放大器、开关和逻辑门等。常用的二极管种类有发光二极管、稳压二极管等。</p><h3 id="2-2-晶体管"><a href="#2-2-晶体管" class="headerlink" title="2.2 晶体管"></a>2.2 晶体管</h3><p>晶体管同样是一种半导体器件，它也在电子学和电路设计中扮演着重要的角色。晶体管可以作为开关或放大器使用，其基本原理也是基于 PN 结的控制。</p><ul><li><p>晶体管有基极（b）、集电极（c）、发射极（e）三个电极，它是由两个 PN 结背对背地连接在一起构成类似于三明治的结构，其最基本的作用是放大，它可以将微弱的电信号变成一定强度的信号。</p></li><li><p>晶体管有一个重要的参数，即电流放大系数 “β”。当在晶体管的基极上施加一个微小的电流时，在集电极上可以得到一个比基极电流大 β 倍的电流，这个电流称为集电极电流。集电极电流随着基极电流的变化而变化，基极电流微小的变化都可以引起集电极电流很大的变化，这就是晶体管放大作用的原理。</p></li></ul><img src="/2024/02/15/post-7/post-7-4.png" class=""><h4 id="2-3-场效应晶体管"><a href="#2-3-场效应晶体管" class="headerlink" title="2.3 场效应晶体管"></a>2.3 场效应晶体管</h4><p>晶体管是依靠输入电流变化来控制输出电流的器件，但理想的放大器是不应该损耗信号源的输出电流的，所以在一个由晶体管构成的放大电路中，因为有基极电流的存在，不可避免地会对输入信号带来损耗。与晶体管不同的是，场效应晶体管（FET）是一种用电压来控制电流的器件，具有很高的输入阻抗，且温度稳定性好、噪声低。</p><h3 id="2-4-集成电路"><a href="#2-4-集成电路" class="headerlink" title="2.4 集成电路"></a>2.4 集成电路</h3><p>集成电路（Integrated Circuit, IC）是采用特定的工艺，将一个电路中所需的晶体管、二极管、电阻、电容和电感等元器件以及布线相互预先连接在一起，制作在一小块半导体晶片上，然后封装在一个管壳内，成为一种具有特定电路功能的电子元器件。</p><p>两种数字集成电路：</p><ul><li><p>传统晶体管构成的数字集成电路（Transistor-Transistor Logic, TTL）</p></li><li><p>基于新型场效应晶体管构成的集成电路，即互补金属氧化物半导体数字集成电路（Complementary Metal Oxide Semiconductor, CMOS）</p></li></ul><h3 id="2-5-模拟和数字"><a href="#2-5-模拟和数字" class="headerlink" title="2.5 模拟和数字"></a>2.5 模拟和数字</h3><p>模拟信号是一种连续的信号，通常采用传感器将模拟信号转换为电流、电压或电阻等电学量，这些量称为模拟量。<br>数字信号是一种非连续信号，通常使用高低电平来表示二进制数 1 和 0。</p><h4 id="2-5-1-模拟电路"><a href="#2-5-1-模拟电路" class="headerlink" title="2.5.1 模拟电路"></a>2.5.1 模拟电路</h4><p>模拟电子电路也被称为线性电路，电路中一般具有输入和输出端，当输入信号的强度变大时，输出信号的强度也会随之变大，这就形成了所谓的线性放大过程。</p><h4 id="2-5-2-数字电路"><a href="#2-5-2-数字电路" class="headerlink" title="2.5.2 数字电路"></a>2.5.2 数字电路</h4><p>数字电路就是用数字信号完成对数字量的算术运算和逻辑运算的电路，其构成的基本单元是逻辑门。数字电路以二值数字逻辑为基础，其工作信号是离散的数字信号。任何复杂的逻辑电路都可以由若干个逻辑门组成。</p><p>7个基本逻辑门：</p><ul><li>或门</li><li>与门</li><li>非门</li><li>与非门</li><li>或非门</li><li>异或门</li><li>同或门</li></ul><p><strong>以上就是最基本的一些硬件知识。此外，模拟电路中的滤波、放大各种电路，数字电路中的组合逻辑、时序逻辑等等还有很多没有介绍到，电路世界也是一个充满探索的领域。</strong></p><h2 id="3-常见电子元器件"><a href="#3-常见电子元器件" class="headerlink" title="3. 常见电子元器件"></a>3. 常见电子元器件</h2><h3 id="3-1-电阻"><a href="#3-1-电阻" class="headerlink" title="3.1 电阻"></a>3.1 电阻</h3><h4 id="3-1-1-常见电阻类型"><a href="#3-1-1-常见电阻类型" class="headerlink" title="3.1.1 常见电阻类型"></a>3.1.1 常见电阻类型</h4><ul><li>直插电阻：这种电阻又称色环电阻。</li><li>贴片电阻：基于表面贴装技术（SMD）制造的电阻。</li></ul><h4 id="3-1-2-阻值表示方法：色标法和文字符号法"><a href="#3-1-2-阻值表示方法：色标法和文字符号法" class="headerlink" title="3.1.2 阻值表示方法：色标法和文字符号法"></a>3.1.2 阻值表示方法：色标法和文字符号法</h4><ul><li><p>色标法：直插电阻表面的色环就是色标法表示阻值的代表，通常有对照表可以参考计算对应电阻。</p></li><li><p>文字符号法：广泛用于贴片电阻，通常精度为 ±5% 的电阻使用三位数字表示阻值，其中前两位数字表示电阻值的有效数字，第三位数字表示电阻值的倍率。</p><blockquote><p>例如“223”，表示电阻的阻值为 22 × 103 &#x3D; 22kΩ。</p></blockquote></li></ul><h4 id="3-1-3-线性电阻和非线性电阻"><a href="#3-1-3-线性电阻和非线性电阻" class="headerlink" title="3.1.3 线性电阻和非线性电阻"></a>3.1.3 线性电阻和非线性电阻</h4><p>根据欧姆定律，电阻在伏安特性曲线中呈线性状态。但也有随温度和电压而变化的非线性电阻：热敏电阻、压敏电阻。</p><h4 id="3-1-4-基本参数"><a href="#3-1-4-基本参数" class="headerlink" title="3.1.4 基本参数"></a>3.1.4 基本参数</h4><ul><li>标称阻值</li><li>额定功率</li><li>允许误差：±0.5%(D) ±1%(F) ±2%(G) ±5%(J) ±10%(K) ±20%(M)</li></ul><h4 id="3-1-5-功能"><a href="#3-1-5-功能" class="headerlink" title="3.1.5 功能"></a>3.1.5 功能</h4><ul><li>分压、限流、测温、防浪涌</li></ul><h3 id="2-2-电位器"><a href="#2-2-电位器" class="headerlink" title="2.2 电位器"></a>2.2 电位器</h3><p>有这样一类电阻，它的阻值是可变的，我们称其为“可变电阻器”或“电位器”，其外观如图1-5所示。电位器通常有两个固定端和一个滑动端，当调节电位器时，滑动端与两个固定端之间的电阻大小会随之改变，进而改变电路中电流或电压强度，实现某些控制功能，如控制音量、调节光照强度等。</p><h3 id="2-3-电容"><a href="#2-3-电容" class="headerlink" title="2.3 电容"></a>2.3 电容</h3><p>电容可以存储电荷，但电路中电容器的作用并不是用于存储电能，而是利用电容器能反复充放电的特点，达到阻直流、通交流的目的。电容在电路图中的表示符号有两种，一种是无极性的电容，一种是有极性的电解电容。无极性的电容用两个平行且粗细相同的线来表示，而有极性的电容则是在无极性电容符号的基础上，在电容的正极标注正号。</p><p>电容的单位是法拉，简称“法”，符号是“F”。法拉是一个比较大的单位，在实际使用时往往达不到这样的取值范围，因此常用的电容单位都比较小，如毫法（mF）、微法（μF）、纳法（nF）、皮法（pF）等。</p><h3 id="2-4-电感"><a href="#2-4-电感" class="headerlink" title="2.4 电感"></a>2.4 电感</h3><ul><li>当导线中有电流流过时，会在导线的周围产生磁场，为了让通电的导线产生更强的磁场，我们可以将导线缠绕起来制成螺线管，这样会使导线周围的磁场相互叠加。</li><li>当线圈中的电流发生变化时，其周围的磁场也会发生相应的变化，此变化的磁场还可使线圈自身产生感应电动势，这种现象称为“自感”；</li><li>如果在一个通电的线圈周围放置另外一个线圈，当通电的线圈中电流发生变化时，它周围的磁场变化会影响另一个线圈，并在另一个线圈的两端产生电压，如果这个线圈是闭合的，将有电流流过这个线圈，这种两个电感线圈靠近时相互影响的现象称为“互感”。</li><li>电感量的单位是亨利，简称“亨”，用字母“H”表示。亨利同样也是一个较大的单位，常用的单位有毫亨（mH）和微亨（μH）等。</li></ul><h3 id="2-5-继电器"><a href="#2-5-继电器" class="headerlink" title="2.5 继电器"></a>2.5 继电器</h3><ul><li>继电器也是基于电磁感应的原理制成的，是一种用小电流控制大电流的电子器件。</li></ul><h3 id="2-6-蜂鸣器"><a href="#2-6-蜂鸣器" class="headerlink" title="2.6 蜂鸣器"></a>2.6 蜂鸣器</h3><ul><li>蜂鸣器是一种会发出声音的电子器件，蜂鸣器的原理与继电器类似，通电的电磁铁吸引振膜振荡产生音频信号，从而发出声音。常用的蜂鸣器分为两种：一种是有源蜂鸣器，它内部设有振荡电路，在它的两个引脚上接上电压就会发出固定频率的声音；另一种是无源蜂鸣器，内部无振荡电路，接上电源后不会发声，使用时需要用不同频率的方波信号来驱动它发声。</li></ul><h3 id="2-7-晶振"><a href="#2-7-晶振" class="headerlink" title="2.7 晶振"></a>2.7 晶振</h3><ul><li><p>晶振是一种用于产生稳定频率的电子元件，通常用于时钟电路、计时器、微控制器等应用中。它的全名是晶体振荡器，主要由晶体和与之配套的振荡电路组成。</p></li><li><p>晶振的工作原理基于晶体的压电效应。晶体振荡器的基本构成包括一个晶体和与之连接的振荡电路。当一个电场被施加到晶体上时，晶体会发生微小的形变，这种形变称为压电效应。反过来，晶体的微小形变会导致电场的产生。通过反馈电路，晶体振荡器能够在特定频率下产生稳定的振荡。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>硬件基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式 Linux 开发环境初步搭建</title>
    <link href="/2023/12/13/post-6/"/>
    <url>/2023/12/13/post-6/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>对于嵌入式 Linux 开发，第一步的难题就是搭建起一个方便易用的开发环境，说着是易用，配置的过程也是较为繁琐，Linux 相比 Windows 之下就是一匹需要驯服的野马。所以本文汇总我使用 iMX6ULL 开发板搭建开发环境的方法和步骤。</strong></p></blockquote><h2 id="VMware-Ubuntu-虚拟机系统安装与配置"><a href="#VMware-Ubuntu-虚拟机系统安装与配置" class="headerlink" title="VMware Ubuntu 虚拟机系统安装与配置"></a>VMware Ubuntu 虚拟机系统安装与配置</h2><p>安装 VMware Workstation 和 下载准备 Ubuntu 系统镜像（ 本文使用 22.04 LTS 发行版 ）。</p><ul><li><p>VMware Workstation Pro 需要付费软件，本文不讨论详细的获取方法。VMware Workstation Player 是免费版本。</p></li><li><p>Ubuntu镜像官网下载 -&gt; <a href="https://ubuntu.com/download/desktop">Download Ubuntu</a></p></li><li><p>VMware Workstation Pro 安装 Ubuntu 过程也不作详细说明，Web 上的教程大同小异。</p></li><li><p>Ubuntu 使用 apt 软件管理器，按照以下步骤更换 apt sources.list 软件源（阿里源、清华源等）以改善软件包管理网络访问质量和速度：</p><ul><li>备份源文件</li></ul> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo cp /etc/apt/source.list /etc/apt/source.list.bak<br></code></pre></td></tr></table></figure><ul><li>使用 Vim 替换<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">清华镜像站</a>提供的配置</li></ul> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/apt/source.list<br></code></pre></td></tr></table></figure><ul><li>刷新数据源</li></ul> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br></code></pre></td></tr></table></figure></li></ul><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><p>除了VMware 和 Ubuntu.</p><p>在Windows下 我们还需要</p><h2 id="开发环境概要"><a href="#开发环境概要" class="headerlink" title="开发环境概要"></a>开发环境概要</h2><ol><li>Windows 平台：使用 Visual Studio Code 编辑源代码；利用 SMB 便捷管理与 Linux 文件和其传输。</li><li>Ubuntu 平台：使用 VMware 虚拟机系统模拟 Linux 开发环境，最主要是在这个交叉编译环境中生成程序文件。</li><li>iMX6ULL 平台：当然，操作系统也是 Linux，但通过 Windows 使用 MobaXterm 串口通信访问开发板终端操作开发板。</li></ol><h2 id="开发局域网环境配置"><a href="#开发局域网环境配置" class="headerlink" title="开发局域网环境配置"></a>开发局域网环境配置</h2><p>上面介绍的三个平台，那么如何通过 MobaXterm 整合连接这三个平台？<br>我们采取的方法是配置这三个平台的网络设备在同一个局域网下。</p><ol><li><p>我住所大致的网络拓扑如图所示。（主路由的LAN口连接到二级路由器LAN口并开启中转桥接模式，充当交换机，二级路由在书桌旁边，这样也方便有线连接开发板。）</p><img src="/2023/12/13/post-6/1.png" class=""><br/><br/></li><li><p>Windows：直接连接二级路由器，一般我们就是这样访问互联网，这个不作太多说明。</p></li><li><p>Ubuntu：注意在 Ubuntu 虚拟机系统中，需要配置两种网络设备，第一种是虚拟机系统默认的 NAT 连接方式，Ubuntu 通过 Windows 访问互联网，这个很好理解。第二种就是单独为 Ubuntu 添加虚拟网卡设备，具体配置方式如下。配置完成后，相当于 Ubuntu 的虚拟网卡也成为了局域网中的网络设备。</p></li><li><p>iMX6Ull: 开发板也是直接使用网线连接 ETH 网口（以太网）到二级路由器，与台式主机一样。</p></li></ol><p>最后接线完成后，这三个平台的设备就处于同一局域网中了。<br>另外建议在主路由器后台管理中，绑定三个设备对应的 MAC 地址，避免 DHCP 频繁变更分配到的 IP 地址。</p><p>在 Windows 和 Ubuntu 终端中分别使用 ipconfig 和 ifconfig 命令可以检查对应 IP 地址。<br>假设三个设备分配的 IP 如下：<br>Windows: 192.168.0.1<br>Ubuntu: 192.168.0.2<br>iMX6ULL: 192.168.0.3</p><p>接下使用 ping 命令检查相互之间是否能正常连接即可。</p><h2 id="交叉编译工具链"><a href="#交叉编译工具链" class="headerlink" title="交叉编译工具链"></a>交叉编译工具链</h2><h2 id="Ubuntu-配置-Samba-Windows-映射路径访问-Ubuntu-文件"><a href="#Ubuntu-配置-Samba-Windows-映射路径访问-Ubuntu-文件" class="headerlink" title="Ubuntu 配置 Samba + Windows 映射路径访问 Ubuntu 文件"></a>Ubuntu 配置 Samba + Windows 映射路径访问 Ubuntu 文件</h2><h2 id="Ubuntu-配置-SSH-MobaXterm-SSH-终端访问"><a href="#Ubuntu-配置-SSH-MobaXterm-SSH-终端访问" class="headerlink" title="Ubuntu 配置 SSH + MobaXterm SSH 终端访问"></a>Ubuntu 配置 SSH + MobaXterm SSH 终端访问</h2><h2 id="开发板连接-Windows-MobaXterm-Serial-终端访问"><a href="#开发板连接-Windows-MobaXterm-Serial-终端访问" class="headerlink" title="开发板连接 Windows + MobaXterm Serial 终端访问"></a>开发板连接 Windows + MobaXterm Serial 终端访问</h2><h2 id="Ubuntu-配置-NFS-挂载目录"><a href="#Ubuntu-配置-NFS-挂载目录" class="headerlink" title="Ubuntu 配置 NFS 挂载目录"></a>Ubuntu 配置 NFS 挂载目录</h2>]]></content>
    
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机/嵌入式/编程等书籍与教程汇总 [2024/02/08 更新]</title>
    <link href="/2023/11/26/post-5/"/>
    <url>/2023/11/26/post-5/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>得益于现有计算机和嵌入式领域的蓬勃发展，越来越多的学习资源触手可及，以下我觉得有必要汇总我学习过或阅读过的书籍和视频，包括一些我认为比较优质的内容。</strong></p></blockquote><h2 id="编程语言-Programming-Language"><a href="#编程语言-Programming-Language" class="headerlink" title="编程语言 - Programming Language"></a>编程语言 - Programming Language</h2><p><strong>C语言</strong></p><p>📕 书籍：<a href="https://book.douban.com/subject/26792521/">C Primer Plus（第6版）</a><br>🎞 视频：<a href="https://www.bilibili.com/video/BV1U44y1y7xN/">C语言从入门到精通 - 2021版 by @比特鹏哥</a></p><h2 id="数据结构与算法-Data-Structures-Algorithms"><a href="#数据结构与算法-Data-Structures-Algorithms" class="headerlink" title="数据结构与算法 - Data Structures &amp; Algorithms"></a>数据结构与算法 - Data Structures &amp; Algorithms</h2><p>📕 书籍：<a href="https://www.hello-algo.com/">Hello 算法</a></p><h2 id="计算机通用基础-Computer-Basic"><a href="#计算机通用基础-Computer-Basic" class="headerlink" title="计算机通用基础 - Computer Basic"></a>计算机通用基础 - Computer Basic</h2><p><strong>计算机原理</strong></p><p>📕 入门三件套书籍：</p><ul><li><a href="https://book.douban.com/subject/26397183/">计算机是如何跑起来的</a>  </li><li><a href="https://book.douban.com/subject/26365491/">程序是如何跑起来的</a></li><li><a href="https://book.douban.com/subject/26941639/">网络是怎么连接的</a></li></ul><h2 id="电子-硬件-Electronics-Hardware"><a href="#电子-硬件-Electronics-Hardware" class="headerlink" title="电子 &amp; 硬件  - Electronics &amp; Hardware"></a>电子 &amp; 硬件  - Electronics &amp; Hardware</h2><p><strong>模拟电路 &amp; 数字电路</strong></p><p>🎞 入门科普视频：</p><ul><li><a href="https://www.bilibili.com/video/BV1774114798/">编程前你最好了解的基本硬件和计算机基础知识（模拟电路）by @Ele实验室</a></li><li><a href="https://www.bilibili.com/video/BV1Hi4y1t7zY/">编程前你最好了解的基本硬件和计算机基础知识（数字电路）by @Ele实验室</a></li></ul><h2 id="单片机-MCU"><a href="#单片机-MCU" class="headerlink" title="单片机 - MCU"></a>单片机 - MCU</h2><p><strong>51 单片机</strong></p><p>🎞 视频：<a href="https://www.bilibili.com/video/BV1Mb411e7re/">51单片机入门教程 - 2020版 by @江协科技</a></p><h2 id="操作系统-OS"><a href="#操作系统-OS" class="headerlink" title="操作系统 - OS"></a>操作系统 - OS</h2><p><strong>Linux</strong></p><p>📕 书籍：<a href="https://book.douban.com/subject/35933905/">Linux 命令行与 shell 脚本编程大全（第4版）</a><br>🎞 视频：<a href="https://www.bilibili.com/video/BV1w4411B7a4/">嵌入式 Linux 快速入门到精通（应用 + 驱动基础入门）by @韦东山</a></p><h2 id="前端-Front-End"><a href="#前端-Front-End" class="headerlink" title="前端 - Front End"></a>前端 - Front End</h2><p><strong>HTML &amp; CSS</strong></p><p>📄 文档：<a href="https://developer.mozilla.org/zh-CN/docs/Learn">MDN Web Docs</a><br>📕 书籍：<a href="https://book.douban.com/subject/30849692/">Web前端开发技术（第3版）</a><br>🎞 视频：<a href="https://www.bilibili.com/video/BV1Kg411T7t9/">前端开发入门教程 HTML + CSS - 2021版 by @黑马程序员</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 语言数据在内存中的存储基本原理</title>
    <link href="/2023/09/25/post-4/"/>
    <url>/2023/09/25/post-4/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>我们都知道，C语言是一门面向过程的、抽象化的通用程序设计语言，广泛应用于底层开发。C语言能以简易的方式编译、处理低级存储器。同是正是因为 C 语言可以使用指针，从而对物理内存地址进行直接操作，这是 C 的最大特点之一。要理解好 C 语言，也需要对数据在内存中存储方式有基本的认识，本文以 C 为例子，介绍数据在内存中存储的基本原理。</strong></p></blockquote><h2 id="内存空间与地址"><a href="#内存空间与地址" class="headerlink" title="内存空间与地址"></a>内存空间与地址</h2><p>下图展示了一个计算机内存条，其中每个黑色方块都包含一块内存空间。我们可以将内存想象成一个巨大的 Excel 表格，其中每个单元格都可以存储一定大小的数据。系统通过内存地址来访问目标位置的数据。计算机根据特定规则为表格中的每个单元格分配编号，确保每个内存空间都有唯一的内存地址。有了这些地址，程序便可以访问内存中的数据。</p><p><strong>最重要的概念：基本数据类型以二进制的形式存储在计算机中。一个二进制位即为 1 比特。在绝大多数现代操作系统中，1字节（byte）由 8 比特（bit）组成。</strong></p><img src="/2023/09/25/post-4/post-4-1.png" class=""><h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h2><h3 id="1-1-类型的基本归类"><a href="#1-1-类型的基本归类" class="headerlink" title="1.1 类型的基本归类"></a>1.1 类型的基本归类</h3><p>当谈及计算机中的数据时，我们会想到文本、图片、视频、语音、3D 模型等各种形式。尽管这些数据的组织形式各异，但它们都由各种基本数据类型构成。</p><p>C语言中有多种基本数据类型，包括整数、浮点数、字符等。这些数据类型在内存中占用的空间大小不同，例如，int通常占用4个字节，float占用4个字节，char占用1个字节。数据类型决定了数据在内存中的存储方式和表示形式，可以分为以下的五大类型：</p><h3 id="1-1-1-整型"><a href="#1-1-1-整型" class="headerlink" title="1.1.1 整型"></a>1.1.1 整型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span><br><span class="hljs-type">signed</span> <span class="hljs-type">char</span><br><span class="hljs-type">short</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> [<span class="hljs-type">int</span>]<br><span class="hljs-type">signed</span> <span class="hljs-type">short</span> [<span class="hljs-type">int</span>]<br><span class="hljs-type">int</span> <br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span><br><span class="hljs-type">signed</span> <span class="hljs-type">int</span><br><span class="hljs-type">long</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span><br><span class="hljs-type">signed</span> <span class="hljs-type">long</span> [<span class="hljs-type">int</span>]<br></code></pre></td></tr></table></figure><h3 id="1-1-2-浮点型"><a href="#1-1-2-浮点型" class="headerlink" title="1.1.2 浮点型"></a>1.1.2 浮点型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span><br><span class="hljs-type">double</span><br></code></pre></td></tr></table></figure><h3 id="1-1-3-构造类型"><a href="#1-1-3-构造类型" class="headerlink" title="1.1.3 构造类型"></a>1.1.3 构造类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">array</span> <span class="hljs-comment">// 数组类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> // 结构体类型 </span><br><span class="hljs-class"><span class="hljs-title">enum</span> // 枚举类型 </span><br><span class="hljs-class"><span class="hljs-title">union</span> // 联合类型</span><br></code></pre></td></tr></table></figure><h3 id="1-1-4-指针类型"><a href="#1-1-4-指针类型" class="headerlink" title="1.1.4 指针类型"></a>1.1.4 指针类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *ptr<br><span class="hljs-type">char</span> *ptr<br><span class="hljs-type">float</span> *ptr<br><span class="hljs-type">void</span> *ptr<br></code></pre></td></tr></table></figure><h3 id="1-1-5-空类型"><a href="#1-1-5-空类型" class="headerlink" title="1.1.5 空类型"></a>1.1.5 空类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-comment">// 函数参数、返回类型、指针</span><br></code></pre></td></tr></table></figure><h2 id="2-整形在内存中的存储"><a href="#2-整形在内存中的存储" class="headerlink" title="2. 整形在内存中的存储"></a>2. 整形在内存中的存储</h2><p>C 变量的创建是根据数据类型在内存中开辟空间。</p><h3 id="2-1-原码、反码、补码"><a href="#2-1-原码、反码、补码" class="headerlink" title="2.1 原码、反码、补码"></a>2.1 原码、反码、补码</h3><p>数据在内存中以 2 进制的形式存储，以整数举例，其 2 进制存储有三种表示形式。</p><p><strong>正整数：原码、反码、补码相同。</strong><br><strong>负整数：原码、反码、补码要进行计算。</strong></p><p>举例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">-10</span>;<br><span class="hljs-comment">// 10000000 00000000 00000000 00001010 - 原码（原始 2 进制表示形式）</span><br><span class="hljs-comment">// 11111111 11111111 11111111 11110101 - 反码（符号位不变，其它位按位取反）</span><br><span class="hljs-comment">// 11111111 11111111 11111111 11110110 - 补码（反码 + 1）</span><br></code></pre></td></tr></table></figure><p>VS Code 调试取 <code>&amp;a</code> 的地址后可以观察发现 16 进制的内存地址所存储的数据为 <code>F6 FF FF FF</code>，这恰好是 2 进制补码的 16 进制数，同时表明了整数在内存中存储的是补码。</p><img src="/2023/09/25/post-4/1.png" class=""><br/><br/><blockquote><p>为什么数据在内存中存放的是补码：因为在计算机组成原理中，补码可以将符号位和数值域统一处理，加法和减法也可以统一处理（CPU只有加法器），此外补码和原码相互转换，运算过程是相同的，无需额外的逻辑硬件电路。</p></blockquote><ul><li>更深入的解释是原码虽然最直观，但存在一些局限性。一方面，负数的原码不能直接用于运算。例如在原码下计算 1 + (−2)，得到的结果是 −3，这显然是不对的。为了解决此问题，计算机引入了反码。如果我们先将原码转换为反码，并在反码下计算 1 + (−2)，最后将结果从反码转换回原码，则可得到正确结果 −1。</li><li>另一方面，数字零的原码有 +0 和 −0 两种表示方式。这意味着数字零对应两个不同的二进制编码，这可能会带来歧义。比如在条件判断中，如果没有区分正零和负零，则可能会导致判断结果出错。而如果我们想处理正零和负零歧义，则需要引入额外的判断操作，这可能会降低计算机的运算效率。</li><li>后面，计算机进一步引入了补码，在负零的反码基础上加 1 会产生进位，但 byte 类型的长度只有 8 位，因此溢出到第 9 位的 1 会被舍弃。也就是说，负零的补码为 0000 0000 ，与正零的补码相同。这意味着在补码表示中只存在一个零，正负零歧义从而得到解决。</li></ul><p>举例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">// 1 - 1;</span><br><span class="hljs-comment">// 1 + (-1);</span><br><span class="hljs-comment">// 00000000 00000000 00000000 00000001 - 1的原码</span><br><span class="hljs-comment">// 10000000 00000000 00000000 00000001 - -1的原码</span><br>    <span class="hljs-comment">// 如果计算机采用原码进行逻辑加减（1+（-1）），得到结果数值如下</span><br>    <span class="hljs-comment">// 10000000 00000000 00000000 00000010 - 是-2？可以看到数值是错误的。</span><br><span class="hljs-comment">// 如果采用补码运算，数值才是正确的，这是计算机组成底层原理的逻辑。</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-大端字节序和小端字节序"><a href="#2-2-大端字节序和小端字节序" class="headerlink" title="2.2 大端字节序和小端字节序"></a>2.2 大端字节序和小端字节序</h3><p>字节序（Byte Order）是指多字节数据在计算机内存中存储时的顺序。字节序分为两种主要类型：大端字节序（Big-Endian）和小端字节序（Little-Endian）。</p><ol><li><p><strong>大端字节序（Big-Endian）</strong>：</p><ul><li>在大端字节序中，多字节数据的最高有效字节（Most Significant Byte，MSB）存储在内存的最低地址处，而最低有效字节（Least Significant Byte，LSB）存储在内存的最高地址处。</li><li>大端字节序的表示方式类似于阅读书写的方式，先读取最高位的字节，然后是次高位，以此类推。</li></ul><p>例如，十六进制数0x12345678在大端字节序中存储为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0x12</span> <span class="hljs-number">0x34</span> <span class="hljs-number">0x56</span> <span class="hljs-number">0x78</span><br></code></pre></td></tr></table></figure></li><li><p><strong>小端字节序（Little-Endian）</strong>：</p><ul><li>在小端字节序中，多字节数据的最低有效字节（LSB）存储在内存的最低地址处，而最高有效字节（MSB）存储在内存的最高地址处。</li><li>小端字节序的表示方式与计算机内部的数据存储方式相符，因此在许多计算机架构中使用较为广泛。</li></ul><p>例如，十六进制数0x12345678在小端字节序中存储为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0x78</span> <span class="hljs-number">0x56</span> <span class="hljs-number">0x34</span> <span class="hljs-number">0x12</span><br></code></pre></td></tr></table></figure></li></ol><p>字节序的选择在不同计算机架构和操作系统中可以有所不同。例如，x86 和 x86-64 架构通常使用小端字节序，而某些大型服务器架构（如SPARC）使用大端字节序。这种差异可能会在数据交换和网络通信中引起问题，因此在跨平台应用程序中，需要特别注意字节序的处理，以确保数据正确解释和传递。通常使用一种标准的字节序协议（如网络字节序）来协调不同架构之间的数据交换。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p><strong>以上就是数据存储的基本原理，C 语言根据数据的类型在内存中开辟空间，操作系统根据内存地址来进行读取操作。整数在计算机中是以补码的形式存储的。在补码表示下，计算机可以对正数和负数的加法一视同仁，不需要为减法操作单独设计特殊的硬件电路，并且不存在正负零歧义的问题。如果深入，还有数据结构、内存管理、浮点数、字符编码等等方向可以探讨，从这里也可以窥探到计算机组成原理和它的体系实在是精妙。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据存储</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Visual Studio Code 中配置 C/C++ 环境</title>
    <link href="/2023/04/23/post-3/"/>
    <url>/2023/04/23/post-3/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>VS Code 作为微软的一款轻量级的代码编辑器，在我先前学习前端的时候就已经爱不释手，加上开源免费，丰富的插件生态特性，可以说是必备的代码编辑器。但在学习 C 的阶段，由于觉得 Visual Studio 2022 比较臃肿，所以便对想在 VS Code 中配置 C&#x2F;C++ 环境，以下将介绍大致的方法。</strong></p></blockquote><h2 id="1-MinGW-安装"><a href="#1-MinGW-安装" class="headerlink" title="1. MinGW 安装"></a>1. MinGW 安装</h2><p>MinGW（Minimalist GNU for Windows）是一个用于 Windows 平台的开发工具集，它允许开发者在 Windows 操作系统上使用 GNU 工具集来编译和构建软件，包括 C、C++ 和其他编程语言。MinGW 的目标是提供一个轻量级、开源的开发环境，使开发者能够在 Windows 上进行跨平台的开发。</p><blockquote><p>✅ VS Code 官方推荐通过 MSYS2 来安装 MinGW，详细请参阅：“<a href="https://code.visualstudio.com/docs/cpp/config-mingw">Using GCC with MinGW</a>”。</p><p>❔ MSYS2 是针对 Windows 的软件分发和构建平台。它提供了一个类 Unix 的环境，一个命令行界面和一个软件库，使得在 Windows 上安装、使用、构建和移植软件更加容易。</p><p>🧲 <a href="https://www.msys2.org/">下载链接</a></p></blockquote><ul><li><p>安装完成后运行 <code>MSYS2</code> 终端（默认 <code>UCRT64</code>），其采用 <code>pacman</code> 软件包管理器，按步骤执行以下代码：</p></li><li><p>设置清华大学软件源 URL：</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -i &quot;s#https\?://mirror.msys2.org/#https://mirrors.tuna.tsinghua.edu.cn/msys2/#g&quot; /etc/pacman.d/mirrorlist*<br></code></pre></td></tr></table></figure><ul><li>更新 MSYS2 所有软件包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -Suy<br></code></pre></td></tr></table></figure><ul><li>安装 MinGW-w64 toolchain</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -S --needed base-devel mingw-w64-ucrt-x86_64-toolchain<br></code></pre></td></tr></table></figure><ul><li>打印版本，检查是否成功安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc --version<br>g++ --version<br>gdb --version<br></code></pre></td></tr></table></figure><h2 id="2-VS-Code-配置"><a href="#2-VS-Code-配置" class="headerlink" title="2. VS Code 配置"></a>2. VS Code 配置</h2><h3 id="2-1-安装插件"><a href="#2-1-安装插件" class="headerlink" title="2.1 安装插件"></a>2.1 安装插件</h3><p>VS Code 基本安装和设置中文语言这里不展开说明，首先在 VS Code 扩展商店中搜索并下载 C&#x2F;C++ 插件安装。</p><img src="/2023/04/23/post-3/post-3-1.png" class=""><br/><br/><p>接下来任意编写一个 <code>test.c</code> 并输入简单的 C 代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-配置-gcc-路径"><a href="#2-2-配置-gcc-路径" class="headerlink" title="2.2 配置 gcc 路径"></a>2.2 配置 gcc 路径</h3><p>键盘快捷键 <code>Ctrl + Shif + P</code> 呼出菜单选择 <code>C/C++:编辑配置(UI)</code>，如红框所示选择自己对应 MinGW <code>bin</code> 路径中的 <code>gcc.exe</code> 作为编译器。</p><img src="/2023/04/23/post-3/post-3-2.png" class=""><br/><h3 id="2-3-设置智能代码提示"><a href="#2-3-设置智能代码提示" class="headerlink" title="2.3 设置智能代码提示"></a>2.3 设置智能代码提示</h3><p>同样在呼出菜单中选择 <code>C/C++:选择 IntelliSense 配置</code>，再选择 MinGW <code>bin</code> 路径中的 <code>gcc.exe</code> 即可。</p><img src="/2023/04/23/post-3/post-3-3.png" class=""><h2 id="3-编译任务配置"><a href="#3-编译任务配置" class="headerlink" title="3. 编译任务配置"></a>3. 编译任务配置</h2><p>通过菜单栏或快捷键 <code>Ctrl + Shif + B</code> 运行生成任务，它会在根目录 <code>.vscode</code> 文件夹下生成 <code>tasks.json</code> 文件。这里我们要特别注意的是 <code>&quot;-g&quot;</code> 和  <code>&quot;-o&quot;</code> 这两项的参数。VS Code 变量参数官方文档：”<a href="https://code.visualstudio.com/docs/editor/variables-reference">Visual Studio Code Variables Reference</a>“。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;tasks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppbuild&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C/C++: gcc.exe 生成活动文件&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:\\msys64\\mingw64\\bin\\gcc.exe&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;-fdiagnostics-color=always&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;-g&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-comment">//&quot;$&#123;file&#125;&quot;,</span><br>                <span class="hljs-string">&quot;$&#123;fileDirname&#125;\\*.c&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// &quot;*.c&quot; 代表编译该源文件所属目录下的全部源文件，单个文件可以更改回上一行的参数。</span><br>                <span class="hljs-string">&quot;-o&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;$&#123;fileDirname&#125;\\output.exe&quot;</span> <span class="hljs-comment">// 生成可执行程序的名称统一命名为 &quot;output.exe&quot;。</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;fileDirname&#125;&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;$gcc&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;detail&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;调试器生成的任务。&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.0.0&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="4-可执行程序运行"><a href="#4-可执行程序运行" class="headerlink" title="4. 可执行程序运行"></a>4. 可执行程序运行</h2><p>编译完成后，在命令行终端输入 <code>./文件路径/文件名&quot;</code> 运行生成的程序。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++环境</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于 Hexo 和 GitHub Pages 的博客建站教程</title>
    <link href="/2023/01/25/post-2/"/>
    <url>/2023/01/25/post-2/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>本文将介绍和总结我参考 Web 上的教程来配置 GitHub Pages 和 Hexo 框架建立博客的大致方法。</strong></p></blockquote><h2 id="1-建站原理"><a href="#1-建站原理" class="headerlink" title="1. 建站原理"></a>1. 建站原理</h2><p><strong>搭建类似本站博客的原理主要有以下四个部分：</strong></p><ol><li><p>博客框架（将用户的输入快速生成由 <code>HTML</code> <code>CSS</code> <code>JavaScript</code> 组成的前端界面，可以对博客进行快速且简便的设置）</p><blockquote><p>常见的博客框架：<code>Hexo</code>  <code>WordPress</code> <code>Jekyll</code></p></blockquote></li><li><p>代码托管平台（为用户提供访问和修改的接口，将博客所需的文件、代码存放在云端）</p><blockquote><p>常见的平台：<code>GitHub</code>  <code>Gitee</code></p></blockquote></li><li><p>站点部署服务（将博客网站目录部署到互联网以便访问浏览）</p><blockquote><p>常见的部署服务：<code>GitHub Pages</code>  <code>Netify</code></p></blockquote></li><li><p>访问加速服务（CDN 加速，通过多节点缓存来提高网络内容的解析和访问速度）</p><blockquote><p>常见的加速服务：<code>Cloudfare</code>  <code>Alibaba</code>  <code>Tencent</code></p></blockquote></li></ol><h2 id="2-Hexo-环境配置"><a href="#2-Hexo-环境配置" class="headerlink" title="2. Hexo 环境配置"></a>2. Hexo 环境配置</h2><h3 id="2-1-新建站点仓库"><a href="#2-1-新建站点仓库" class="headerlink" title="2.1 新建站点仓库"></a>2.1 新建站点仓库</h3><p>首先在 Github 中新建仓库，详细信息请参阅：”<a href="https://docs.github.com/zh/pages/getting-started-with-github-pages/creating-a-github-pages-site#creating-a-repository-for-your-site">为站点创建仓库</a>“。</p><blockquote><p>❗ <strong>注意仓库命名格式 -  <code>&lt;user&gt;.github.io</code></strong></p></blockquote><img src="/2023/01/25/post-2/post-2-1.webp" class="">  <h3 id="2-2-Git-安装"><a href="#2-2-Git-安装" class="headerlink" title="2.2 Git 安装"></a>2.2 Git 安装</h3><blockquote><p>Git 是一个用于管理源代码的分布式版本控制系统。版本控制系统会在您修改文件时记录并保存更改，使您可以随时恢复以前的工作版本。<br>🧲 <a href="https://git-scm.com/download/win%22">下载链接</a></p></blockquote><ul><li>Windows 平台正常选择 <code>64-bit Git for Windows Setup</code> 即可。</li><li>安装完成后任意路径运行 <code>Git Bash</code> 终端，设置 Git 用户名和邮箱。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git --version # 验证版本号是否成功安装<br>git config –global &quot;user_name” # 双引号内替换用户名<br>git config –global &quot;user_email&quot; # 双引号内替换个人邮箱<br></code></pre></td></tr></table></figure><h3 id="2-3-配置-SSH-公匙"><a href="#2-3-配置-SSH-公匙" class="headerlink" title="2.3 配置 SSH 公匙"></a>2.3 配置 SSH 公匙</h3><ul><li>Git Bash 运行以下代码生成 SSH 密匙，详细信息请参阅：”<a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent#generating-a-new-ssh-key">生成新 SSH 密钥</a>“。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot; # 双引号内替换个人邮箱<br></code></pre></td></tr></table></figure><ul><li>生成成功后，将 SSH 公钥复制到剪贴板。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">clip &lt; ~/.ssh/id_ed25519.pub<br></code></pre></td></tr></table></figure><ul><li><p>将复制到的 SSH 公匙添加到账户设置，详细信息请参阅：”<a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account#adding-a-new-ssh-key-to-your-account">向你的帐户添加新的 SSH 密钥</a>“。</p></li><li><p>到此即完成 Git 的安装和配置，后续可以开始使用 SSH 方式来进行 Git 连接。</p></li></ul><blockquote><p>✅ <strong>推荐使用 SSH 方式，HTTPS 方式每次连接均需要输入用户名和密码。</strong></p></blockquote><h3 id="2-4-Node-js-安装"><a href="#2-4-Node-js-安装" class="headerlink" title="2.4 Node.js 安装"></a>2.4 Node.js 安装</h3><blockquote><p>Node.js（通常简称为Node）是一个用于构建服务器端和网络应用程序的运行时环境。Node.js是基于 Chrome V8 JavaScript 引擎构建的，它允许您使用 JavaScript 编程语言来创建高性能和可伸缩的网络应用程序。</p><p>🧲 <a href="https://nodejs.cn/download/">下载链接</a></p></blockquote><ul><li>正常选择 LTS 稳定版本或最新版本 msi 安装包下载安装。</li><li>安装完成后终端运行以下命令检查是否成功返回版本号，即代表安装成功。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">node -v<br>npm -v<br></code></pre></td></tr></table></figure><h2 id="3-Hexo-安装"><a href="#3-Hexo-安装" class="headerlink" title="3. Hexo 安装"></a>3. Hexo 安装</h2><blockquote><p>Hexo 是一个快速、简单且强大的静态博客生成器，基于 Node.js 开发。它允许用户使用 Markdown 格式的文本来撰写博客文章，然后将这些文章转换成静态 HTML 页面，方便发布在网站上。Hexo 的目标是提供一个轻松管理和发布博客内容的解决方案，同时具备高度可定制性。</p></blockquote><ul><li>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo，详细信息请参阅：”<a href="https://hexo.io/zh-cn/docs/">Hexo 文档</a>“。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><ul><li>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init &lt;folder&gt;<br>cd &lt;folder&gt;<br>npm install<br></code></pre></td></tr></table></figure><ul><li>本地运行 Hexo 并预览效果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean # 清理缓存<br>hexo g # 生成静态文件<br>hexo s # 运行本地服务器<br></code></pre></td></tr></table></figure><ul><li>本地使用浏览器打开 <code>http://localhost:4000</code> 即可以显示初始化的 Hexo 主题。</li></ul><h2 id="4-Hexo-使用"><a href="#4-Hexo-使用" class="headerlink" title="4. Hexo 使用"></a>4. Hexo 使用</h2><h3 id="4-1-创建文章"><a href="#4-1-创建文章" class="headerlink" title="4.1 创建文章"></a>4.1 创建文章</h3><p>运行示例代码创建第一篇博客文章，详细参阅：”<a href="https://hexo.io/zh-cn/docs/writing">写作 | Hexo</a>“。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new &lt;post_title&gt; # 替换博客标题<br></code></pre></td></tr></table></figure><blockquote><p>✅ <strong>编辑器推荐使用 VS Code，VS Code 是开源免费的且推荐配合以下两个插件使用：</strong></p><ul><li><strong><a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one">Markdown All in One</a></strong></li><li><strong><a href="https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint">markdownlint</a></strong></li></ul><p>✅ <strong>Markdown 语法参阅 - <a href="https://markdown.com.cn/">Markdown 官方教程</a></strong></p></blockquote><h3 id="4-2-资源文件组织化"><a href="#4-2-资源文件组织化" class="headerlink" title="4.2 资源文件组织化"></a>4.2 资源文件组织化</h3><p>这里推荐更改 Hexo 配置文件 <code>_config.yml</code> 中的 <code>post_asset_folder</code> 选项属性为 <code>true</code>。</p><blockquote><p>开启此选项后，每次运行上面创建文章的示例代码时，Hexo 会自动创建一个同名资源文件夹，那么后续将需要引用的图片资源文件都可以放进该文件夹，写作时就可以通过使用相对路径引用资源，这个方法便于更好地管理资源文件。</p></blockquote><p>假设我已经将文件名为 1.jpg 的图片放入同时生成的资源文件夹中，那么引用图片的示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hexo">&#123;% asset_img 1.jpg [title] %&#125;<br></code></pre></td></tr></table></figure><p><strong>至此 Hexo 安装和基本使用均介绍到此，后续就可以按照个人喜好开始配置主题和自定义网站，这些需要一定时间去深入探索。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>建站</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello, World!</title>
    <link href="/2023/01/15/post-1/"/>
    <url>/2023/01/15/post-1/</url>
    
    <content type="html"><![CDATA[<h3 id="My-Blog"><a href="#My-Blog" class="headerlink" title="My Blog"></a>My Blog</h3><p>Hello, 博客开张了。一直以来，自己希望能搭建一个网站，博客自然是一个不错的选择，加上目前保持有在学习嵌入式和编程的相关技能，更加需要记录下一些历程。所以经过多番折腾，终于这次部署完成了这个博客。在这里我会分享一些日常自己折腾的东西或学习历程上各种笔记总结。站点采用了常用的 Hexo 框架和 Github Pages 部署，后续再慢慢对 Fluid 主题进行自定义完善修改。</p><p><strong>旅途刚开始…</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
